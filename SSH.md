## SSH & SSH Forwarding Agent

### What is SSH?

SSH is the most common way of connecting to a remote Linux server is through SSH. SSH stands for **Secure Shell** and provides a safe and secure way of executing commands, making changes, and configuring services remotely.
When you connect through SSH, you log in using an account that exists on the remote server.
The standard TCP port for SSH is 22.

Learn about SSH, Architecture, RFCs,OpenSSH, Putty: https://en.wikipedia.org/wiki/Secure_Shell

---

### How does SSH work?

When you connect through SSH, you will be dropped into a shell session, which is a text-based interface where you can interact with your server. For the duration of your SSH session, any commands that you type into your local terminal are sent through an encrypted SSH tunnel and executed on your server.

The SSH connection is implemented using a client-server model. This means that for an SSH connection to be established, the remote machine must be running a piece of software called an SSH daemon. This software listens for connections on a specific network port, authenticates connection requests, and spawns the appropriate environment if the user provides the correct credentials.

The user’s computer must have an SSH client. This is a piece of software that knows how to communicate using the SSH protocol and can be given information about the remote host to connect to, the username to use, and the credentials that should be passed to authenticate. The client can also specify certain details about the connection type they would like to establish.

---

### How does SSH authenticate its Users trying to connect?

Clients generally authenticate either using passwords (less secure and not recommended) or SSH keys, which are very secure.

Password logins are encrypted and are easy to understand for new users. However, automated bots and malicious users will often repeatedly try to authenticate to accounts that allow password-based logins, which can lead to security compromises. For this reason, we recommend always setting up SSH key-based authentication for most configurations.

SSH keys are a matching set of cryptographic keys which can be used for authentication. Each set contains a public and a private key. The public key can be shared freely without concern, while the private key must be vigilantly guarded and never exposed to anyone.

To authenticate using SSH keys, a user must have an SSH key pair on their local computer. On the remote server, the public key must be copied to a file within the user’s home directory at ~/.ssh/authorized_keys. This file contains a list of public keys, one-per-line, that are authorized to log into this account.

When a client connects to the host, wishing to use SSH key authentication, it will inform the server of this intent and will tell the server which public key to use. The server then checks its authorized_keys file for the public key, generates a random string, and encrypts it using the public key. This encrypted message can only be decrypted with the associated private key. The server will send this encrypted message to the client to test whether they actually have the associated private key.

Upon receipt of this message, the client will decrypt it using the private key and combine the random string that is revealed with a previously negotiated session ID. It then generates an MD5 hash of this value and transmits it back to the server. The server already had the original message and the session ID, so it can compare an MD5 hash generated by those values and determine that the client must have the private key.


---

### Generating and working with SSH keys

Generating a new SSH public and private key pair on your local computer is the first step towards authenticating with a remote server without a password. Unless there is a good reason not to, you should always authenticate using SSH keys.

A number of cryptographic algorithms can be used to generate SSH keys, including RSA, DSA, and ECDSA. RSA keys are generally preferred and are the default key type.

To generate an RSA key pair on your local computer, type:

```
ssh-keygen
 
Generating public/private rsa key pair.
Enter file in which to save the key (/home/demo/.ssh/id_rsa):
```
This prompt allows you to choose the location to store your RSA private key. Press ENTER to leave this as the default, which will store them in the .ssh hidden directory in your user’s home directory. Leaving the default location selected will allow your SSH client to find the keys automatically.

```
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
```
The next prompt allows you to enter a passphrase of an arbitrary length to secure your private key. By default, you will have to enter any passphrase you set here every time you use the private key, as an additional security measure. Feel free to press ENTER to leave this blank if you do not want a passphrase. Keep in mind though that this will allow anyone who gains control of your private key to login to your servers.
This procedure has generated an RSA SSH key pair, located in the .ssh hidden directory within your user’s home directory. These files are:

```
~/.ssh/id_rsa: The private key.                                      DO NOT SHARE THIS FILE!
~/.ssh/id_rsa.pub: The associated public key.                        This can be shared freely without consequence.
```

* Link to the detailed aspects of SSH: https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys

---

### What is the SSH Forwarding Agent?
SSH agent forwarding allows you to use your private, local SSH key remotely without worrying about leaving confidential data on the server you're working with. It's built into ssh , and is easy to set up and use.

Good visual understanding of SSH forwarding agent: http://www.unixwiz.net/techtips/ssh-agent-forwarding.html#:~:text=issues-,public%20key%20access%20with%20agent%20forwarding,-With
Highlighted text shows the basic use of a forwarding agent and the -A switch: https://dev.to/levivm/how-to-use-ssh-and-ssh-agent-forwarding-more-secure-ssh-2c32#:~:text=There%20is%20a,your%20local%20machine

---




### AUTHENTICATION SUMMARY
The OpenSSH SSH client supports SSH protocol 2.
     
The methods available for authentication are: GSSAPI-based authentication, host-based
 authentication, public key authentication, challenge-response authentication, and
 password authentication.  Authentication methods are tried in the order specified
 above, though PreferredAuthentications can be used to change the default order.

 Host-based authentication works as follows: If the machine the user logs in from is
 listed in /etc/hosts.equiv or /etc/shosts.equiv on the remote machine, and the user
 names are the same on both sides, or if the files ~/.rhosts or ~/.shosts exist in the
 user's home directory on the remote machine and contain a line containing the name of
 the client machine and the name of the user on that machine, the user is considered
 for login.  Additionally, the server must be able to verify the client's host key
 (see the description of /etc/ssh/ssh_known_hosts and ~/.ssh/known_hosts, below) for
 login to be permitted.  This authentication method closes security holes due to IP
 spoofing, DNS spoofing, and routing spoofing.  [Note to the administrator:
 /etc/hosts.equiv, ~/.rhosts, and the rlogin/rsh protocol in general, are inherently
 insecure and should be disabled if security is desired.]

 **Public key authentication works as follows:** The scheme is based on public-key cryp-
 tography, using cryptosystems where encryption and decryption are done using separate
 keys, and it is unfeasible to derive the decryption key from the encryption key.  The
 idea is that each user creates a public/private key pair for authentication purposes.
 The server knows the public key, and only the user knows the private key.  ssh imple-
 ments public key authentication protocol automatically, using one of the DSA, ECDSA,
 Ed25519 or RSA algorithms.  The HISTORY section of ssl(8) contains a brief discussion
 of the DSA and RSA algorithms.

 The file ~/.ssh/authorized_keys lists the public keys that are permitted for logging
 in.  When the user logs in, the ssh program tells the server which key pair it would
 like to use for authentication.  The client proves that it has access to the private
 key and the server checks that the corresponding public key is authorized to accept
 the account.

 The server may inform the client of errors that prevented public key authentication
 from succeeding after authentication completes using a different method.  These may
 be viewed by increasing the LogLevel to DEBUG or higher (e.g. by using the -v flag).

 The user creates his/her key pair by running ssh-keygen(1).  This stores the private
 key in ~/.ssh/id_dsa (DSA), ~/.ssh/id_ecdsa (ECDSA), ~/.ssh/id_ed25519 (Ed25519), or
 ~/.ssh/id_rsa (RSA) and stores the public key in ~/.ssh/id_dsa.pub (DSA),
 ~/.ssh/id_ecdsa.pub (ECDSA), ~/.ssh/id_ed25519.pub (Ed25519), or ~/.ssh/id_rsa.pub
 (RSA) in the user's home directory.  The user should then copy the public key to
 ~/.ssh/authorized_keys in his/her home directory on the remote machine.  The
 authorized_keys file corresponds to the conventional ~/.rhosts file, and has one key
 per line, though the lines can be very long.  After this, the user can log in without
 giving the password.

 A variation on public key authentication is available in the form of certificate
 authentication: instead of a set of public/private keys, signed certificates are
 used.  This has the advantage that a single trusted certification authority can be
 used in place of many public/private keys.  See the CERTIFICATES section of
 ssh-keygen(1) for more information.

 The most convenient way to use public key or certificate authentication may be with
 an authentication agent.  See ssh-agent(1) and (optionally) the AddKeysToAgent direc-
 tive in ssh_config(5) for more information.

 Challenge-response authentication works as follows: The server sends an arbitrary
 "challenge" text, and prompts for a response.  Examples of challenge-response authen-
 tication include BSD Authentication (see login.conf(5)) and PAM (some non-OpenBSD
 systems).

 Finally, if other authentication methods fail, ssh prompts the user for a password.
 The password is sent to the remote host for checking; however, since all communica-
 tions are encrypted, the password cannot be seen by someone listening on the network.

 ssh automatically maintains and checks a database containing identification for all
 hosts it has ever been used with.  Host keys are stored in ~/.ssh/known_hosts in the
 user's home directory.  Additionally, the file /etc/ssh/ssh_known_hosts is automati-
 cally checked for known hosts.  Any new hosts are automatically added to the user's
 file.  If a host's identification ever changes, ssh warns about this and disables
 password authentication to prevent server spoofing or man-in-the-middle attacks,
 which could otherwise be used to circumvent the encryption.  The
 StrictHostKeyChecking option can be used to control logins to machines whose host key
 is not known or has changed.

 When the user's identity has been accepted by the server, the server either executes
 the given command in a non-interactive session or, if no command has been specified,
 logs into the machine and gives the user a normal shell as an interactive session.
 All communication with the remote command or shell will be automatically encrypted.

 If an interactive session is requested ssh by default will only request a pseudo-ter-
 minal (pty) for interactive sessions when the client has one.  The flags -T and -t
 can be used to override this behaviour.

 If a pseudo-terminal has been allocated the user may use the escape characters noted
 below.

 If no pseudo-terminal has been allocated, the session is transparent and can be used
 to reliably transfer binary data.  On most systems, setting the escape character to
none'' will also make the session transparent even if a tty is used.

The session terminates when the command or shell on the remote machine exits and all
X11 and TCP connections have been closed.

---

### Linux SysAdmin Troblesooting issues in SSH

#### ISSUE1
```
$ ssh 192.168.1.84

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
SHA256:I02UyJs2vS0ym4jWn5upAWZDqwu5RjMg4aM9hPq8G1k.
Please contact your system administrator.
Add correct host key in /Users/khess/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /Users/khess/.ssh/known_hosts:4
ECDSA host key for 192.168.1.84 has changed and you have requested strict checking.
Host key verification failed.
```
`known_hosts` file is a simple text file that lives inside a hidden directory (.ssh) in your home directory. What has happened here is that you've attempted to connect to a system that no longer has the IP address 192.168.1.84. A different system has that IP address and SSH is complaining that you might be getting hacked. The reality is often much less exciting. Your known_hosts file may not sync with actual host reality. First, remove a known_hosts entry with the ssh-keygen command:
```
$ ssh-keygen -R 192.168.1.84 -f .ssh/known_hosts

 Host 192.168.1.84 found: line 4
.ssh/known_hosts updated.
Original contents retained as .ssh/known_hosts.old
```

or just remove the known_hosts:
``` rm home/username/.ssh/known_hosts ```

The original entry is saved to .ssh/known_hosts.old in case it's needed in the future.

After removing the 192.168.1.84 entry from the  known_hosts file, I attempted the connection again to host 192.168.1.84:
```
$ ssh 192.168.1.84
The authenticity of host '192.168.1.84 (192.168.1.84)' can't be established.
ECDSA key fingerprint is SHA256:I02UyJs2vS0ym4jWn5upAWZDqwu5RjMg4aM9hPq8G1k.
Are you sure you want to continue connecting (yes/no)? yes

Warning: Permanently added '192.168.1.84' (ECDSA) to the list of known hosts.
```
You can see that the key I added now matches the one listed in the error at the beginning of the article. To verify a host's key, issue the following command on the remote host:
```
$ ssh-keygen -lf /etc/ssh/ssh_host_ecdsa_key.pub
256 SHA256:I02UyJs2vS0ym4jWn5upAWZDqwu5RjMg4aM9hPq8G1k no comment (ECDSA)
```
Link to this article: https://www.redhat.com/sysadmin/linux-knownhosts-failures
---
